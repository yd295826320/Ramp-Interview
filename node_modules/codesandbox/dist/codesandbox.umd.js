(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.codesandbox = {})));
}(this, (function (exports) { 'use strict';

/**
 * Returns an action that describes to open a notification in the editor
 *
 * @export
 * @param {string} title
 * @param {('notice' | 'warning' | 'error' | 'success')} [notificationType='notice']
 * @param {number} [timeAlive=2] How long the notification should show in seconds
 * @returns {NotificationAction}
 */
function show(title, notificationType, timeAlive) {
    if (notificationType === void 0) { notificationType = 'notice'; }
    if (timeAlive === void 0) { timeAlive = 2; }
    // TODO automatically add type: 'action', maybe do this after conversion to TS
    return {
        type: 'action',
        action: 'notification',
        title: title,
        notificationType: notificationType,
        timeAlive: timeAlive,
    };
}


var notifications = Object.freeze({
	show: show
});

function openModule(id, lineNumber) {
    if (lineNumber === void 0) { lineNumber = 1; }
    // TODO automatically add type: 'action', maybe do this after conversion to TS
    return {
        type: 'action',
        action: 'editor.open-module',
        moduleId: id,
        lineNumber: lineNumber,
    };
}


var editor = Object.freeze({
	openModule: openModule
});

function add(dependencyName) {
    return {
        type: 'action',
        action: 'source.dependencies.add',
        dependency: dependencyName,
    };
}


var d = Object.freeze({
	add: add
});

function rename(moduleId, title) {
    return {
        type: 'action',
        action: 'source.module.rename',
        moduleId: moduleId,
        title: title,
    };
}


var m = Object.freeze({
	rename: rename
});

var dependencies = d;
var modules = m;


var source = Object.freeze({
	dependencies: dependencies,
	modules: modules
});

/**
 * Returns an action that describes to show an error
 * in the code of the editor (with the red squiggles)
 *
 * @export
 * @param {string} title
 * @param {string} message
 * @param {ErrorOptions} { line, column, moduleId, payload }
 * @returns {ErrorAction}
 */
function show$1(title, message, _a) {
    var line = _a.line, column = _a.column, moduleId = _a.moduleId, payload = _a.payload;
    return {
        title: title,
        message: message,
        line: line,
        column: column,
        moduleId: moduleId,
        payload: payload,
        type: 'action',
        action: 'show-error',
    };
}


var error = Object.freeze({
	show: show$1
});

// All actions of the editor are defined here. The sandbox can send messages
// like `source.files.rename` which the editor will see as an action to rename
// a module. This will allow plugins to alter project content in the future
var actions = {
    notifications: notifications,
    editor: editor,
    source: source,
    error: error,
};

var host = process.env.CODESANDBOX_HOST;
var host$1 = host || 'https://codesandbox.io';

// import * as debug from 'debug';
// Whether the tab has a connection with the editor
var isStandalone = typeof window === 'undefined' || (!window.opener && window.parent === window);
/**
 * Send a message to the editor, this is most probably an action you generated
 *
 * @export
 * @param {*} message
 * @returns
 */
function dispatch(message) {
    if (!message)
        return;
    if (isStandalone)
        return;
    if (window.opener) {
        window.opener.postMessage(message, host$1);
    }
    else {
        window.parent.postMessage(message, host$1);
    }
}

// Import here Polyfills if needed. Recommended core-js (npm i -D core-js)
// import "core-js/fn/array.find"
// ...

exports.actions = actions;
exports.isStandalone = isStandalone;
exports.dispatch = dispatch;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=codesandbox.umd.js.map
